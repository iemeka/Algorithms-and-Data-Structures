Post call or no post call dependency
* tail recursion
* non-tail recursion

Approach - (not future and past thingy)
* Top down
* Bottom up

Patterns:  divide | conquer | combine | backtracking
* divide and conquer - clear and predefined path to solution. Num of steps are fixed 
* decrease and conquer
* backtracking: - exact path to solution is not known in advance. num of stepes to build a solution is not known

Optimization:
* Prunning (in backtracking) - cutting out unnecessary paths (implement)
* Memoisation/caching - optimization technique to speed up a program by storing input and their result to avoid expensive calls, improving runtime in exchange for aditional space

* Recursion and/to Iteration

Complexity Analysis
* master theorem - (majorly divide and conquer recursion pattern)
* Depth of recursion - maximum depth of a recursive function is the time complexity
* space complexity:
    Recursion based:
    - Tail recursion
    - Non-tail recursion
    Non-recursion based:
    - Memoisation - 

* Recursion and yield

Questions
* backtracking - nqueens idea - combination -  conains dup, brackets ordering
* try another solution for climb stairs. backtracking [1,2] 5 rows. generate all combinations, build the tree - backtracking and Prunning.

Others
* use draw.io for drawings
* Self questions in pswda
* see if you can make a small node for each page to define some things on git or perhaps you use comments here.

Next - organise here.
Next - check organisation and pick questions for for each sections.
